\input texinfo   @c -*- mode: texinfo; coding: us-ascii; -*-
@c This file is part of the GNU Generic Security Service Library.
@c See below for copyright and license.

@setfilename gss.info
@include version.texi
@settitle GNU Generic Security Service Library
@finalout

@c Unify some of the indices.
@syncodeindex tp fn
@syncodeindex pg fn
@syncodeindex vr fn

@copying
This manual is last updated @value{UPDATED} for version
@value{VERSION} of GNU GSS.

Copyright @copyright{} 2003, 2004 Simon Josefsson.

@quotation
Permission is granted to copy, distribute and/or modify this document
under the terms of the GNU Free Documentation License, Version 1.1 or
any later version published by the Free Software Foundation; with the
Invariant Sections being ``Commercial Support'' and ``Criticism of
GSS'', the Front-Cover texts being ``A GNU Manual'', and with the
Back-Cover Texts being ``You have freedom to copy and modify this GNU
Manual, like GNU software''.  A copy of the license is included in the
section entitled ``GNU Free Documentation License''.
@end quotation
@end copying

@dircategory GNU Libraries
@direntry
* gss: (gss).			Generic Security Service API Library
@end direntry

@titlepage
@title Generic Security Service
@subtitle GSS-API Library for the GNU system
@subtitle for version @value{VERSION}, @value{UPDATED}
@author Simon Josefsson
@page
@vskip 0pt plus 1filll
@insertcopying
@end titlepage

@contents

@ifnottex
@node Top
@top GNU Generic Security Service

@insertcopying
@end ifnottex

@menu
* Introduction::                How to use this manual.
* Preparation::                 What you should do before using the library.
* Standard GSS API::            Reference documentation for the Standard API.
* Extended GSS API::            Non-standard functions.
* Acknowledgements::            Whom to blame.

Appendices

* Criticism of GSS::            Why you maybe shouldn't use GSS.
@c * Copying::                     How you can copy and share GPL GSS-API.
@c * Copying This Manual::         How you can copy and share this manual.

Indices

* Concept Index::               Index of concepts and programs.
* API Index::                   Index of functions, variables and data types.
@end menu

@c **********************************************************
@c *******************  Introduction  ***********************
@c **********************************************************
@node Introduction
@chapter Introduction

GSS is an implementation of the Generic Security Service Application
Program Interface (GSS-API).  GSS-API is used by network servers to
provide security services, e.g., to authenticate SMTP/IMAP clients
against SMTP/IMAP servers.  GSS consists of a library and a manual.

GSS is developed for the GNU/Linux system, but runs on over 20
platforms including most major Unix platforms and Windows, and many
kind of devices including iPAQ handhelds and S/390 mainframes.

GSS is a GNU project, and is licensed under the GNU General Public
License.

@menu
* Getting Started::
* Features::
* GSS-API Overview::
* Supported Platforms::
* Commercial Support::
* Downloading and Installing::
* Bug Reports::
* Contributing::
* Planned Features::
@end menu

@node Getting Started
@section Getting Started

This manual documents the GSS programming interface.  All functions
and data types provided by the library are explained.

The reader is assumed to possess basic familiarity with GSS-API and
network programming in C or C++.  For general GSS-API information, and
some programming examples, there is a guide available online at
@url{http://docs.sun.com/db/doc/816-1331}.

This manual can be used in several ways.  If read from the beginning
to the end, it gives a good introduction into the library and how it
can be used in an application.  Forward references are included where
necessary.  Later on, the manual can be used as a reference manual to
get just the information needed about any particular interface of the
library.  Experienced programmers might want to start looking at the
examples at the end of the manual, and then only read up those parts
of the interface which are unclear.

@node Features
@section Features

GSS might have a couple of advantages over other libraries doing a
similar job.

@table @asis
@item It's Free Software
Anybody can use, modify, and redistribute it under the terms of the
GNU General Public License.

@item It's thread-safe
No global variables are used and multiple library handles and session
handles may be used in parallell.

@item It's internationalized
It handles non-ASCII names and user visible strings used in the
library (e.g., error messages) can be translated into the users'
language.

@item It's portable
It should work on all Unix like operating systems, including Windows.

@end table

@node GSS-API Overview
@section GSS-API Overview

This section describes GSS-API from a protocol point of view.

The Generic Security Service Application Programming Interface
provides security services to calling applications.  It allows a
communicating application to authenticate the user associated with
another application, to delegate rights to another application, and to
apply security services such as confidentiality and integrity on a
per-message basis.

There are four stages to using the GSS-API:

@enumerate
@item
The application acquires a set of credentials with which it may prove
its identity to other processes. The application's credentials vouch
for its global identity, which may or may not be related to any local
username under which it may be running.

@item
A pair of communicating applications establish a joint security
context using their credentials.  The security context is a pair of
GSS-API data structures that contain shared state information, which
is required in order that per-message security services may be
provided.  Examples of state that might be shared between applications
as part of a security context are cryptographic keys, and message
sequence numbers.  As part of the establishment of a security context,
the context initiator is authenticated to the responder, and may
require that the responder is authenticated in turn.  The initiator
may optionally give the responder the right to initiate further
security contexts, acting as an agent or delegate of the initiator.
This transfer of rights is termed delegation, and is achieved by
creating a set of credentials, similar to those used by the initiating
application, but which may be used by the responder.

To establish and maintain the shared information that makes up the
security context, certain GSS-API calls will return a token data
structure, which is an opaque data type that may contain
cryptographically protected data.  The caller of such a GSS-API
routine is responsible for transferring the token to the peer
application, encapsulated if necessary in an application- application
protocol.  On receipt of such a token, the peer application should
pass it to a corresponding GSS-API routine which will decode the token
and extract the information, updating the security context state
information accordingly.

@item
Per-message services are invoked to apply either: integrity and data
origin authentication, or confidentiality, integrity and data origin
authentication to application data, which are treated by GSS-API as
arbitrary octet-strings.  An application transmitting a message that
it wishes to protect will call the appropriate GSS-API routine
(gss_get_mic or gss_wrap) to apply protection, specifying the
appropriate security context, and send the resulting token to the
receiving application.  The receiver will pass the received token
(and, in the case of data protected by gss_get_mic, the accompanying
message-data) to the corresponding decoding routine (gss_verify_mic or
gss_unwrap) to remove the protection and validate the data.

@item
At the completion of a communications session (which may extend across
several transport connections), each application calls a GSS-API
routine to delete the security context.  Multiple contexts may also be
used (either successively or simultaneously) within a single
communications association, at the option of the applications.
@end enumerate

@node Supported Platforms
@section Supported Platforms

GSS has at some point in time been tested on the following platforms.

@enumerate

@item Debian GNU/Linux 3.0 (Woody)
@cindex Debian

GCC 2.95.4 and GNU Make. This is the main development platform.
@code{alphaev67-unknown-linux-gnu}, @code{alphaev6-unknown-linux-gnu},
@code{arm-unknown-linux-gnu}, @code{hppa-unknown-linux-gnu},
@code{hppa64-unknown-linux-gnu}, @code{i686-pc-linux-gnu},
@code{ia64-unknown-linux-gnu}, @code{m68k-unknown-linux-gnu},
@code{mips-unknown-linux-gnu}, @code{mipsel-unknown-linux-gnu},
@code{powerpc-unknown-linux-gnu}, @code{s390-ibm-linux-gnu},
@code{sparc-unknown-linux-gnu}.

@item Debian GNU/Linux 2.1
@cindex Debian

GCC 2.95.1 and GNU Make. @code{armv4l-unknown-linux-gnu}.

@item Tru64 UNIX
@cindex Tru64

Tru64 UNIX C compiler and Tru64 Make. @code{alphaev67-dec-osf5.1},
@code{alphaev68-dec-osf5.1}.

@item SuSE Linux 7.1
@cindex SuSE

GCC 2.96 and GNU Make. @code{alphaev6-unknown-linux-gnu},
@code{alphaev67-unknown-linux-gnu}.

@item SuSE Linux 7.2a
@cindex SuSE Linux

GCC 3.0 and GNU Make. @code{ia64-unknown-linux-gnu}.

@item RedHat Linux 7.2
@cindex RedHat

GCC 2.96 and GNU Make. @code{alphaev6-unknown-linux-gnu},
@code{alphaev67-unknown-linux-gnu}, @code{ia64-unknown-linux-gnu}.

@item RedHat Linux 8.0
@cindex RedHat

GCC 3.2 and GNU Make. @code{i686-pc-linux-gnu}.

@item RedHat Advanced Server 2.1
@cindex RedHat Advanced Server

GCC 2.96 and GNU Make. @code{i686-pc-linux-gnu}.

@item Slackware Linux 8.0.01
@cindex RedHat

GCC 2.95.3 and GNU Make. @code{i686-pc-linux-gnu}.

@item Mandrake Linux 9.0
@cindex Mandrake

GCC 3.2 and GNU Make. @code{i686-pc-linux-gnu}.

@item IRIX 6.5
@cindex IRIX

MIPS C compiler, IRIX Make. @code{mips-sgi-irix6.5}.

@item AIX 4.3.2
@cindex AIX

IBM C for AIX compiler, AIX Make.  @code{rs6000-ibm-aix4.3.2.0}.

@item Microsoft Windows 2000 (Cygwin)
@cindex Windows

GCC 3.2, GNU make. @code{i686-pc-cygwin}.

@item HP-UX 11
@cindex HP-UX

HP-UX C compiler and HP Make. @code{ia64-hp-hpux11.22},
@code{hppa2.0w-hp-hpux11.11}.

@item SUN Solaris 2.8
@cindex Solaris

Sun WorkShop Compiler C 6.0 and SUN Make. @code{sparc-sun-solaris2.8}.

@item NetBSD 1.6
@cindex NetBSD

GCC 2.95.3 and GNU Make. @code{alpha-unknown-netbsd1.6},
@code{i386-unknown-netbsdelf1.6}.

@item OpenBSD 3.1 and 3.2
@cindex OpenBSD

GCC 2.95.3 and GNU Make. @code{alpha-unknown-openbsd3.1},
@code{i386-unknown-openbsd3.1}.

@item FreeBSD 4.7
@cindex FreeBSD

GCC 2.95.4 and GNU Make. @code{alpha-unknown-freebsd4.7},
@code{i386-unknown-freebsd4.7}.

@end enumerate

If you use GSS on, or port GSS to, a new platform please report it to
the author.

@node Commercial Support
@section Commercial Support

Commercial support is available for users of GNU GSS.  The kind of
support that can be purchased may include:

@itemize

@item Implement new features.
Such as a new GSS-API mechanism.

@item Port GSS to new platforms.
This could include porting to an embedded platforms that may need
memory or size optimization.

@item Integrating GSS as a security environment in your existing project.

@item System design of components related to GSS-API.

@end itemize

If you are interested, please write to:

@verbatim
Simon Josefsson Datakonsult
Drottningholmsv. 70
112 42 Stockholm
Sweden

E-mail: simon@josefsson.org
@end verbatim

If your company provide support related to GNU GSS and would like to
be mentioned here, contact the author (@pxref{Bug Reports}).

@node Downloading and Installing
@section Downloading and Installing
@cindex Installation
@cindex Download

The package can be downloaded from several places, including
@url{http://josefsson.org/gss/releases/}.  The latest version is
stored in a file, e.g., @samp{gss-@value{VERSION}.tar.gz} where the
@samp{@value{VERSION}} indicate the highest version number.

The package is then extracted, configured and built like many other
packages that use Autoconf.  For detailed information on configuring
and building it, refer to the @file{INSTALL} file that is part of the
distribution archive.

Here is an example terminal session that download, configure, build
and install the package.  You will need a few basic tools, such as
@samp{sh}, @samp{make} and @samp{cc}.

@example
$ wget -q http://josefsson.org/gss/releases/gss-@value{VERSION}.tar.gz
$ tar xfz gss-@value{VERSION}.tar.gz
$ cd gss-@value{VERSION}/
$ ./configure
...
$ make
...
$ make install
...
@end example

After that GSS should be properly installed and ready for use.

@node Bug Reports
@section Bug Reports
@cindex Reporting Bugs

If you think you have found a bug in GSS, please investigate it and
report it.

@itemize @bullet

@item Please make sure that the bug is really in GSS, and
preferably also check that it hasn't already been fixed in the latest
version.

@item You have to send us a test case that makes it possible for us to
reproduce the bug.

@item You also have to explain what is wrong; if you get a crash, or
if the results printed are not good and in that case, in what way.
Make sure that the bug report includes all information you would need
to fix this kind of bug for someone else.

@end itemize

Please make an effort to produce a self-contained report, with
something definite that can be tested or debugged.  Vague queries or
piecemeal messages are difficult to act on and don't help the
development effort.

If your bug report is good, we will do our best to help you to get a
corrected version of the software; if the bug report is poor, we won't
do anything about it (apart from asking you to send better bug
reports).

If you think something in this manual is unclear, or downright
incorrect, or if the language needs to be improved, please also send a
note.

Send your bug report to:

@center @samp{bug-gss@@josefsson.org}

@node Contributing
@section Contributing
@cindex Contributing
@cindex Hacking

If you want to submit a patch for inclusion -- from solve a typo you
discovered, up to adding support for a new feature -- you should
submit it as a bug report (@pxref{Bug Reports}).  There are some
things that you can do to increase the chances for it to be included
in the official package.

Unless your patch is very small (say, under 10 lines) we require that
you assign the copyright of your work to the Free Software Foundation.
This is to protect the freedom of the project.  If you have not
already signed papers, we will send you the necessary information when
you submit your contribution.

For contributions that doesn't consist of actual programming code, the
only guidelines are common sense.  Use it.

For code contributions, a number of style guides will help you:

@itemize @bullet

@item Coding Style.
Follow the GNU Standards document (@pxref{top, GNU Coding Standards,,
standards}).

If you normally code using another coding standard, there is no
problem, but you should use @samp{indent} to reformat the code
(@pxref{top, GNU Indent,, indent}) before submitting your work.

@item Use the unified diff format @samp{diff -u}.

@item Return errors.
No reason whatsoever should abort the execution of the library.  Even
memory allocation errors, e.g. when malloc return NULL, should work
although result in an error code.

@item Design with thread safety in mind.
Don't use global variables.  Don't even write to per-handle global
variables unless the documented behaviour of the function you write is
to write to the per-handle global variable.

@item Avoid using the C math library.
It causes problems for embedded implementations, and in most
situations it is very easy to avoid using it.

@item Document your functions.
Use comments before each function headers, that, if properly
formatted, are extracted into Texinfo manuals and GTK-DOC web pages.

@item Supply a ChangeLog and NEWS entries, where appropriate.

@end itemize

@node Planned Features
@section Planned Features
@cindex Todo list
@cindex Future goals

This is also known as the ``todo list''.  If you like to start working
on anything, please let me know so work duplication can be avoided.

@itemize
@item Support non-blocking mode.
This would be an API extension.  It could work by forking a process
and interface to it, or by using a user-specific daemon.  E.g., h =
START(accept_sec_context(...)), FINISHED(h), ret = FINISH(h), ABORT(h).

@item Support loadable modules via dlopen, a'la Solaris GSS.

@item Port to Cyclone? CCured?

@end itemize


@c **********************************************************
@c *******************  Preparation  ************************
@c **********************************************************
@node Preparation
@chapter Preparation

To use GSS, you have to perform some changes to your sources and the
build system.  The necessary changes are small and explained in the
following sections.  At the end of this chapter, it is described how
the library is initialized, and how the requirements of the library
are verified.

A faster way to find out how to adapt your application for use with
GSS may be to look at the examples at the end of this manual.

@menu
* Header::
* Initialization::
* Version Check::
* Building the source::
* Out of Memory handling::
@end menu

@node Header
@section Header

@cindex Header files
All standard interfaces (data types and functions) of the official GSS
API are defined in the header file @file{gss/api.h}.  The file is
taken verbatim from the RFC (after correcting a few typos) where it is
known as @file{gssapi.h}.  However, to be able to co-exist gracefully
with other GSS-API implementation, the name @file{gssapi.h} was
changed.

The header file @file{gss.h} includes @file{gss/api.h}, add a few
non-standard extensions (by including @file{gss/ext.h}), takes care of
including header files related to all supported mechanisms (e.g.,
@file{gss/krb5.h}) and finally add C++ namespace protection of all
definitions.  Therefore, including @file{gss.h} in your project is
recommended over @file{gss/api.h}.  If using @file{gss.h} instead of
@file{gss/api.h} causes problems, it should be regarded a bug.

You must include either file in all programs using the library, either
directly or through some other header file, like this:

@example
#include <gss.h>
@end example

The name space of GSS is @code{gss_*} for function names, @code{gss_*}
for data types and @code{GSS_*} for other symbols.  In addition the
same name prefixes with one prepended underscore are reserved for
internal use and should never be used by an application.

Each supported GSS mechanism may want to expose mechanism specific
functionality, and can do so through one or more header files under
the @file{gss/} directory.  The Kerberos 5 mechanism uses the file
@file{gss/krb5.h}, but again, it is included (with C++ namespace
fixes) from @file{gss.h}.

@node Initialization
@section Initialization

GSS does not need to be initialized before it can be used.

In order to take advantage of the internationalisation features in
GSS, e.g. translated error messages, the application must set the
current locale using @code{setlocale()} before calling, e.g.,
@code{gss_display_status()}.  This is typically done in @code{main()}
as in the following example.

@example
#include <gss.h>
#include <locale.h>
...
  setlocale (LC_ALL, "");
@end example

@node Version Check
@section Version Check

It is often desirable to check that the version of GSS used is indeed
one which fits all requirements.  Even with binary compatibility new
features may have been introduced but due to problem with the dynamic
linker an old version is actually used.  So you may want to check that
the version is okay right after program startup.  The function is
called @code{gss_check_version()} and is described formally in
@xref{Extended GSS API}.

The normal way to use the function is to put something similar to the
following early in your @code{main()}:

@example
#include <gss.h>
...
  if (!gss_check_version (GSS_VERSION))
    @{
      printf ("gss_check_version() failed:\n"
              "Header file incompatible with shared library.\n");
      exit(1);
    @}
@end example

@node Building the source
@section Building the source
@cindex Compiling your application

If you want to compile a source file that includes the @file{gss.h} header
file, you must make sure that the compiler can find it in the
directory hierarchy.  This is accomplished by adding the path to the
directory in which the header file is located to the compilers include
file search path (via the @option{-I} option).

However, the path to the include file is determined at the time the
source is configured.  To solve this problem, GSS uses the external
package @command{pkg-config} that knows the path to the include file
and other configuration options.  The options that need to be added to
the compiler invocation at compile time are output by the
@option{--cflags} option to @command{pkg-config gss}.  The following
example shows how it can be used at the command line:

@example
gcc -c foo.c `pkg-config gss --cflags`
@end example

Adding the output of @samp{pkg-config gss --cflags} to the compilers
command line will ensure that the compiler can find the @file{gss.h} header
file.

A similar problem occurs when linking the program with the library.
Again, the compiler has to find the library files.  For this to work,
the path to the library files has to be added to the library search
path (via the @option{-L} option).  For this, the option
@option{--libs} to @command{pkg-config gss} can be used.  For
convenience, this option also outputs all other options that are
required to link the program with the GSS libarary (for instance, the
@samp{-lshishi} option).  The example shows how to link @file{foo.o}
with GSS into a program @command{foo}.

@example
gcc -o foo foo.o `pkg-config gss --libs`
@end example

Of course you can also combine both examples to a single command by
specifying both options to @command{pkg-config}:

@example
gcc -o foo foo.c `pkg-config gss --cflags --libs`
@end example

@node Out of Memory handling
@section Out of Memory handling

@cindex Out of Memory handling
@cindex Memory allocation failure
The GSS API does not have a standard error code for the out of memory
error condition.  Instead of adding a non-standard error code, this
library has chosen to adopt a different strategy.  Out of memory
handling happens in rare situations, but performing the out of memory
error handling after almost all API function invocations pollute your
source code and might make it harder to spot more serious problems.
The strategy chosen improve code readability and robustness.

@cindex Aborting execution
For most applications, aborting the application with an error message
when the out of memory situation occur is the best that can be wished
for.  This is how the library behaves by default.

@vindex xalloc_fail_func
However, we realize that some applications may not want to have the
GSS library abort execution in any situation.  The GSS library support
a hook to let the application regain control and perform its own
cleanups when an out of memory situation has occured.  The application
can define a function (having a @code{void} prototype, i.e., no return
value and no parameters) and set the library variable
@code{xalloc_fail_func} to that function.  The variable should be
declared as follows.

@example
extern void (*xalloc_fail_func) (void);
@end example

The GSS library will invoke this function if an out of memory error
occurs.  Note that after this the GSS library is in an undefined
state, so you must unload or restart the application to continue call
GSS library functions.  The hook is only intended to allow the
application to log the situation in a special way.  Of course, care
must be taken to not allocate more memory, as that will likely also
fail.

@c **********************************************************
@c ************** Generic Security Services  ****************
@c **********************************************************
@node Standard GSS API
@chapter Standard GSS API

@menu
* Error Handling::		How errors in GSS are reported and handled.
* Credential Management::	Standard GSS credential functions.
* Context-Level Routines::	Standard GSS context functions.
* Per-Message Routines::	Standard GSS per-message functions.
* Name Manipulation::		Standard GSS name manipulation functions.
* Miscellaneous Routines::	Standard miscellaneous functions.
@end menu

@node Error Handling
@section Error Handling

@cindex status codes
@cindex mechanism status codes
Every GSS-API routine returns two distinct values to report status
information to the caller: GSS status codes and Mechanism status
codes.

@subsection GSS status codes

GSS-API routines return GSS status codes as their OM_uint32 function
value.  These codes indicate errors that are independent of the
underlying mechanism(s) used to provide the security service.  The
errors that can be indicated via a GSS status code are either generic
API routine errors (errors that are defined in the GSS-API
specification) or calling errors (errors that are specific to these
language bindings).

A GSS status code can indicate a single fatal generic API error from
the routine and a single calling error.  In addition, supplementary
status information may be indicated via the setting of bits in the
supplementary info field of a GSS status code.

These errors are encoded into the 32-bit GSS status code as follows:

@verbatim
      MSB                                                        LSB
      |------------------------------------------------------------|
      |  Calling Error | Routine Error  |    Supplementary Info    |
      |------------------------------------------------------------|
   Bit 31            24 23            16 15                       0
@end verbatim

Hence if a GSS-API routine returns a GSS status code whose upper 16
bits contain a non-zero value, the call failed.  If the calling error
field is non-zero, the invoking application's call of the routine was
erroneous.  Calling errors are defined in table 3-1.  If the routine
error field is non-zero, the routine failed for one of the routine-
specific reasons listed below in table 3-2.  Whether or not the upper
16 bits indicate a failure or a success, the routine may indicate
additional information by setting bits in the supplementary info field
of the status code. The meaning of individual bits is listed below in
table 3-3.

@vindex GSS_S_...
@verbatim
   Table 3-1  Calling Errors

   Name                   Value in field           Meaning
   ----                   --------------           -------
   GSS_S_CALL_INACCESSIBLE_READ  1       A required input parameter
                                         could not be read
   GSS_S_CALL_INACCESSIBLE_WRITE 2       A required output parameter
                                          could not be written.
   GSS_S_CALL_BAD_STRUCTURE      3       A parameter was malformed
@end verbatim

@verbatim
   Table 3-2  Routine Errors

   Name                   Value in field           Meaning
   ----                   --------------           -------
   GSS_S_BAD_MECH                1       An unsupported mechanism
                                         was requested
   GSS_S_BAD_NAME                2       An invalid name was
                                         supplied
   GSS_S_BAD_NAMETYPE            3       A supplied name was of an
                                         unsupported type
   GSS_S_BAD_BINDINGS            4       Incorrect channel bindings
                                         were supplied
   GSS_S_BAD_STATUS              5       An invalid status code was
                                         supplied
   GSS_S_BAD_MIC GSS_S_BAD_SIG   6       A token had an invalid MIC
   GSS_S_NO_CRED                 7       No credentials were
                                         supplied, or the
                                         credentials were
                                         unavailable or
                                         inaccessible.
   GSS_S_NO_CONTEXT              8       No context has been
                                         established
   GSS_S_DEFECTIVE_TOKEN         9       A token was invalid
   GSS_S_DEFECTIVE_CREDENTIAL   10       A credential was invalid
   GSS_S_CREDENTIALS_EXPIRED    11       The referenced credentials
                                         have expired
   GSS_S_CONTEXT_EXPIRED        12       The context has expired
   GSS_S_FAILURE                13       Miscellaneous failure (see
                                         text)
   GSS_S_BAD_QOP                14       The quality-of-protection
                                         requested could not be
                                         provided
   GSS_S_UNAUTHORIZED           15       The operation is forbidden
                                         by local security policy
   GSS_S_UNAVAILABLE            16       The operation or option is
                                         unavailable
   GSS_S_DUPLICATE_ELEMENT      17       The requested credential
                                         element already exists
   GSS_S_NAME_NOT_MN            18       The provided name was not a
                                         mechanism name
@end verbatim

@verbatim
   Table 3-3  Supplementary Status Bits

   Name                   Bit Number           Meaning
   ----                   ----------           -------
   GSS_S_CONTINUE_NEEDED   0 (LSB)   Returned only by
                                     gss_init_sec_context or
                                     gss_accept_sec_context. The
                                     routine must be called again
                                     to complete its function.
                                     See routine documentation for
                                     detailed description
   GSS_S_DUPLICATE_TOKEN   1         The token was a duplicate of
                                     an earlier token
   GSS_S_OLD_TOKEN         2         The token's validity period
                                     has expired
   GSS_S_UNSEQ_TOKEN       3         A later token has already been
                                     processed
   GSS_S_GAP_TOKEN         4         An expected per-message token
                                     was not received
@end verbatim

The routine documentation also uses the name GSS_S_COMPLETE, which is
a zero value, to indicate an absence of any API errors or
supplementary information bits.

@findex GSS_CALLING_ERROR
@findex GSS_ROUTINE_ERROR
@findex GSS_SUPPLEMENTARY_INFO
@findex GSS_ERROR
All GSS_S_xxx symbols equate to complete OM_uint32 status codes,
rather than to bitfield values.  For example, the actual value of the
symbol GSS_S_BAD_NAMETYPE (value 3 in the routine error field) is
3<<16.  The macros GSS_CALLING_ERROR(), GSS_ROUTINE_ERROR() and
GSS_SUPPLEMENTARY_INFO() are provided, each of which takes a GSS
status code and removes all but the relevant field.  For example, the
value obtained by applying GSS_ROUTINE_ERROR to a status code removes
the calling errors and supplementary info fields, leaving only the
routine errors field.  The values delivered by these macros may be
directly compared with a GSS_S_xxx symbol of the appropriate type.
The macro GSS_ERROR() is also provided, which when applied to a GSS
status code returns a non-zero value if the status code indicated a
calling or routine error, and a zero value otherwise.  All macros
defined by GSS-API evaluate their argument(s) exactly once.

A GSS-API implementation may choose to signal calling errors in a
platform-specific manner instead of, or in addition to the routine
value; routine errors and supplementary info should be returned via
major status values only.

The GSS major status code GSS_S_FAILURE is used to indicate that the
underlying mechanism detected an error for which no specific GSS
status code is defined.  The mechanism-specific status code will
provide more details about the error.

@subsection Mechanism-specific status codes

GSS-API routines return a minor_status parameter, which is used to
indicate specialized errors from the underlying security mechanism.
This parameter may contain a single mechanism-specific error,
indicated by a OM_uint32 value.

The minor_status parameter will always be set by a GSS-API routine,
even if it returns a calling error or one of the generic API errors
indicated above as fatal, although most other output parameters may
remain unset in such cases.  However, output parameters that are
expected to return pointers to storage allocated by a routine must
always be set by the routine, even in the event of an error, although
in such cases the GSS-API routine may elect to set the returned
parameter value to NULL to indicate that no storage was actually
allocated.  Any length field associated with such pointers (as in a
gss_buffer_desc structure) should also be set to zero in such cases.

@node Credential Management
@section Credential Management

@verbatim
   Table 2-1  GSS-API Credential-management Routines

   Routine                Section              Function
   -------                -------              --------
   gss_acquire_cred           5.2  Assume a global identity; Obtain
                                   a GSS-API credential handle for
                                   pre-existing credentials.
   gss_add_cred               5.3  Construct credentials
                                   incrementally
   gss_inquire_cred           5.21 Obtain information about a
                                   credential
   gss_inquire_cred_by_mech   5.22 Obtain per-mechanism information
                                   about a credential.
   gss_release_cred           5.27 Discard a credential handle.
@end verbatim

@deftypefun OM_uint32 gss_acquire_cred (OM_uint32 *minor_status, const gss_name_t desired_name, OM_uint32 time_req, const gss_OID_set desired_mechs, gss_cred_usage_t cred_usage, gss_cred_id_t *output_cred_handle, gss_OID_set *actual_mechs, OM_uint32 *time_rec)

@var{minor_status}: Integer, modify. Mechanism specific status code.

@var{desired_name}: gss_name_t, read. Name of principal whose
credential should be acquired.

@var{time_req}: Integer, read, optional number of seconds that
credentials should remain valid. Specify GSS_C_INDEFINITE to request
that the credentials have the maximum permitted lifetime.

@var{desired_mechs}: Set of Object IDs, read, optional set of
underlying security mechanisms that may be used.  GSS_C_NO_OID_SET may
be used to obtain an implementation-specific default.

@var{cred_usage}: gss_cred_usage_t, read. GSS_C_BOTH - Credentials may
be used either to initiate or accept security contexts.
GSS_C_INITIATE - Credentials will only be used to initiate security
contexts.  GSS_C_ACCEPT - Credentials will only be used to accept
security contexts.

@var{output_cred_handle}: gss_cred_id_t, modify. The returned
credential handle.  Resources associated with this credential handle
must be released by the application after use with a call to
gss_release_cred().

@var{actual_mechs}: Set of Object IDs, modify, optional. The set of
mechanisms for which the credential is valid.  Storage associated with
the returned OID-set must be released by the application after use
with a call to gss_release_oid_set().  Specify NULL if not required.

@var{time_rec}: Integer, modify, optional. Actual number of seconds
for which the returned credentials will remain valid.  If the
implementation does not support expiration of credentials, the value
GSS_C_INDEFINITE will be returned. Specify NULL if not required

Allows an application to acquire a handle for a pre-existing
credential by name.  GSS-API implementations must impose a local
access-control policy on callers of this routine to prevent
unauthorized callers from acquiring credentials to which they are not
entitled.  This routine is not intended to provide a "login to the
network" function, as such a function would involve the creation of
new credentials rather than merely acquiring a handle to existing
credentials.  Such functions, if required, should be defined in
implementation-specific extensions to the API.

If desired_name is GSS_C_NO_NAME, the call is interpreted as a request
for a credential handle that will invoke default behavior when passed
to gss_init_sec_context() (if cred_usage is GSS_C_INITIATE or
GSS_C_BOTH) or gss_accept_sec_context() (if cred_usage is GSS_C_ACCEPT
or GSS_C_BOTH).

Mechanisms should honor the desired_mechs parameter, and return a
credential that is suitable to use only with the requested mechanisms.
An exception to this is the case where one underlying credential
element can be shared by multiple mechanisms; in this case it is
permissible for an implementation to indicate all mechanisms with
which the credential element may be used.  If desired_mechs is an
empty set, behavior is undefined.

This routine is expected to be used primarily by context acceptors,
since implementations are likely to provide mechanism-specific ways of
obtaining GSS-API initiator credentials from the system login process.
Some implementations may therefore not support the acquisition of
GSS_C_INITIATE or GSS_C_BOTH credentials via gss_acquire_cred for any
name other than GSS_C_NO_NAME, or a name produced by applying either
gss_inquire_cred to a valid credential, or gss_inquire_context to an
active context.

If credential acquisition is time-consuming for a mechanism, the
mechanism may choose to delay the actual acquisition until the
credential is required (e.g. by gss_init_sec_context or
gss_accept_sec_context).  Such mechanism-specific implementation
decisions should be invisible to the calling application; thus a call
of gss_inquire_cred immediately following the call of gss_acquire_cred
must return valid credential data, and may therefore incur the
overhead of a deferred credential acquisition.

Valid return values and their meaning:

@code{GSS_S_COMPLETE}: Successful completion.

@code{GSS_S_BAD_MECH}: Unavailable mechanism requested.

@code{GSS_S_BAD_NAMETYPE}: Type contained within desired_name
parameter is not supported.

@code{GSS_S_BAD_NAME}: Value supplied for desired_name parameter is
ill formed.

@code{GSS_S_CREDENTIALS_EXPIRED}: The credentials could not be
acquired Because they have expired.

@code{GSS_S_NO_CRED}: No credentials were found for the specified
name.
@end deftypefun

@deftypefun OM_uint32 gss_add_cred (OM_uint32 *minor_status, const gss_cred_id_t input_cred_handle, const gss_name_t desired_name, const gss_OID desired_mech, gss_cred_usage_t cred_usage, OM_uint32 initiator_time_req, OM_uint32 acceptor_time_req, gss_cred_id_t *output_cred_handle, gss_OID_set *actual_mechs, OM_uint32 *initiator_time_rec, OM_uint32 *acceptor_time_rec)

@var{minor_status}: Integer, modify.  Mechanism specific status code.

@var{input_cred_handle}: gss_cred_id_t, read, optional.  The
credential to which a credential-element will be added.  If
GSS_C_NO_CREDENTIAL is specified, the routine will compose the new
credential based on default behavior (see description above).  Note
that, while the credential-handle is not modified by gss_add_cred(),
the underlying credential will be modified if output_credential_handle
is NULL.

@var{desired_name}: gss_name_t, read.  Name of principal whose
credential should be acquired.

@var{desired_mech}: Object ID, read.  Underlying security mechanism
with which the credential may be used.

@var{cred_usage}: gss_cred_usage_t, read.  GSS_C_BOTH - Credential may
be used either to initiate or accept security contexts.
GSS_C_INITIATE - Credential will only be used to initiate security
contexts.  GSS_C_ACCEPT - Credential will only be used to accept
security contexts.

@var{initiator_time_req}: Integer, read, optional.  number of seconds
that the credential should remain valid for initiating security
contexts.  This argument is ignored if the composed credentials are of
type GSS_C_ACCEPT.  Specify GSS_C_INDEFINITE to request that the
credentials have the maximum permitted initiator lifetime.

@var{acceptor_time_req}: Integer, read, optional.  number of seconds
that the credential should remain valid for accepting security
contexts.  This argument is ignored if the composed credentials are of
type GSS_C_INITIATE.  Specify GSS_C_INDEFINITE to request that the
credentials have the maximum permitted initiator lifetime.

@var{output_cred_handle}: gss_cred_id_t, modify, optional.  The
returned credential handle, containing the new credential-element and
all the credential-elements from input_cred_handle.  If a valid
pointer to a gss_cred_id_t is supplied for this parameter,
gss_add_cred creates a new credential handle containing all
credential-elements from the input_cred_handle and the newly acquired
credential-element; if NULL is specified for this parameter, the newly
acquired credential-element will be added to the credential identified
by input_cred_handle.

The resources associated with any credential handle returned via this
parameter must be released by the application after use with a call to
gss_release_cred().

@var{actual_mechs}: Set of Object IDs, modify, optional.  The complete
set of mechanisms for which the new credential is valid.  Storage for
the returned OID-set must be freed by the application after use with a
call to gss_release_oid_set(). Specify NULL if not required.

@var{initiator_time_rec}: Integer, modify, optional.  Actual number of
seconds for which the returned credentials will remain valid for
initiating contexts using the specified mechanism.  If the
implementation or mechanism does not support expiration of
credentials, the value GSS_C_INDEFINITE will be returned. Specify NULL
if not required

@var{acceptor_time_rec}: Integer, modify, optional.  Actual number of
seconds for which the returned credentials will remain valid for
accepting security contexts using the specified mechanism.  If the
implementation or mechanism does not support expiration of
credentials, the value GSS_C_INDEFINITE will be returned. Specify NULL
if not required

Adds a credential-element to a credential.  The credential-element is
identified by the name of the principal to which it refers.  GSS-API
implementations must impose a local access-control policy on callers
of this routine to prevent unauthorized callers from acquiring
credential-elements to which they are not entitled. This routine is
not intended to provide a "login to the network" function, as such a
function would involve the creation of new mechanism-specific
authentication data, rather than merely acquiring a GSS-API handle to
existing data.  Such functions, if required, should be defined in
implementation-specific extensions to the API.

If desired_name is GSS_C_NO_NAME, the call is interpreted as a request
to add a credential element that will invoke default behavior when
passed to gss_init_sec_context() (if cred_usage is GSS_C_INITIATE or
GSS_C_BOTH) or gss_accept_sec_context() (if cred_usage is GSS_C_ACCEPT
or GSS_C_BOTH).

This routine is expected to be used primarily by context acceptors,
since implementations are likely to provide mechanism-specific ways of
obtaining GSS-API initiator credentials from the system login process.
Some implementations may therefore not support the acquisition of
GSS_C_INITIATE or GSS_C_BOTH credentials via gss_acquire_cred for any
name other than GSS_C_NO_NAME, or a name produced by applying either
gss_inquire_cred to a valid credential, or gss_inquire_context to an
active context.

If credential acquisition is time-consuming for a mechanism, the
mechanism may choose to delay the actual acquisition until the
credential is required (e.g. by gss_init_sec_context or
gss_accept_sec_context).  Such mechanism-specific implementation
decisions should be invisible to the calling application; thus a call
of gss_inquire_cred immediately following the call of gss_add_cred
must return valid credential data, and may therefore incur the
overhead of a deferred credential acquisition.

This routine can be used to either compose a new credential containing
all credential-elements of the original in addition to the
newly-acquire credential-element, or to add the new credential-
element to an existing credential. If NULL is specified for the
output_cred_handle parameter argument, the new credential-element will
be added to the credential identified by input_cred_handle; if a valid
pointer is specified for the output_cred_handle parameter, a new
credential handle will be created.

If GSS_C_NO_CREDENTIAL is specified as the input_cred_handle,
gss_add_cred will compose a credential (and set the output_cred_handle
parameter accordingly) based on default behavior.  That is, the call
will have the same effect as if the application had first made a call
to gss_acquire_cred(), specifying the same usage and passing
GSS_C_NO_NAME as the desired_name parameter to obtain an explicit
credential handle embodying default behavior, passed this credential
handle to gss_add_cred(), and finally called gss_release_cred() on the
first credential handle.

If GSS_C_NO_CREDENTIAL is specified as the input_cred_handle
parameter, a non-NULL output_cred_handle must be supplied.

Valid return values and their meaning:

@code{GSS_S_COMPLETE}: Successful completion.

@code{GSS_S_BAD_MECH}: Unavailable mechanism requested.

@code{GSS_S_BAD_NAMETYPE}: Type contained within desired_name
parameter is not supported.

@code{GSS_S_BAD_NAME}: Value supplied for desired_name parameter is
ill-formed.

@code{GSS_S_DUPLICATE_ELEMENT}: The credential already contains an
element for the requested mechanism with overlapping usage and
validity period.

@code{GSS_S_CREDENTIALS_EXPIRED}: The required credentials could not
be added because they have expired.

@code{GSS_S_NO_CRED}: No credentials were found for the specified
name.

@end deftypefun

@deftypefun OM_uint32 gss_inquire_cred (OM_uint32 *minor_status, const gss_cred_id_t cred_handle, gss_name_t *name, OM_uint32 *lifetime, gss_cred_usage_t *cred_usage, gss_OID_set *mechanisms)

@var{minor_status}: Integer, modify.  Mechanism specific status code

@var{cred_handle}: gss_cred_id_t, read.  A handle that refers to the
target credential.  Specify GSS_C_NO_CREDENTIAL to inquire about the
default initiator principal.

@var{name}: gss_name_t, modify, optional.  The name whose identity the
credential asserts.  Storage associated with this name should be freed
by the application after use with a call to gss_release_name().
Specify NULL if not required.

@var{lifetime}: Integer, modify, optional.  The number of seconds for
which the credential will remain valid.  If the credential has
expired, this parameter will be set to zero.  If the implementation
does not support credential expiration, the value GSS_C_INDEFINITE
will be returned.  Specify NULL if not required.

@var{cred_usage}: gss_cred_usage_t, modify, optional.  How the
credential may be used.  One of the following: GSS_C_INITIATE,
GSS_C_ACCEPT, GSS_C_BOTH. Specify NULL if not required.

@var{mechanisms}: gss_OID_set, modify, optional.  Set of mechanisms
supported by the credential.  Storage associated with this OID set
must be freed by the application after use with a call to
gss_release_oid_set().  Specify NULL if not required.

Obtains information about a credential.

Valid return values and their meaning:

@code{GSS_S_COMPLETE}: Successful completion

@code{GSS_S_NO_CRED}: The referenced credentials could not be accessed.

@code{GSS_S_DEFECTIVE_CREDENTIAL}: The referenced credentials were invalid.

@code{GSS_S_CREDENTIALS_EXPIRED}: The referenced credentials have
expired.  If the lifetime parameter was not passed as NULL, it will be
set to 0.

@end deftypefun

@deftypefun OM_uint32 gss_inquire_cred_by_mech (OM_uint32 *minor_status, const gss_cred_id_t cred_handle, const gss_OID mech_type, gss_name_t *name, OM_uint32 *initiator_lifetime, OM_uint32 *acceptor_lifetime, gss_cred_usage_t *cred_usage)

@var{minor_status}: Integer, modify.  Mechanism specific status code

@var{cred_handle}: gss_cred_id_t, read.  A handle that refers to the
target credential.  Specify GSS_C_NO_CREDENTIAL to inquire about the
default initiator principal.

@var{mech_type}: gss_OID, read.  The mechanism for which information
should be returned.

@var{name}: gss_name_t, modify, optional.  The name whose identity the
credential asserts.  Storage associated with this name must be freed
by the application after use with a call to gss_release_name().
Specify NULL if not required.

@var{initiator_lifetime}: Integer, modify, optional.  The number of
seconds for which the credential will remain capable of initiating
security contexts under the specified mechanism.  If the credential
can no longer be used to initiate contexts, or if the credential usage
for this mechanism is GSS_C_ACCEPT, this parameter will be set to
zero.  If the implementation does not support expiration of initiator
credentials, the value GSS_C_INDEFINITE will be returned.  Specify
NULL if not required.

@var{acceptor_lifetime}: Integer, modify, optional.  The number of
seconds for which the credential will remain capable of accepting
security contexts under the specified mechanism.  If the credential
can no longer be used to accept contexts, or if the credential usage
for this mechanism is GSS_C_INITIATE, this parameter will be set to
zero. If the implementation does not support expiration of acceptor
credentials, the value GSS_C_INDEFINITE will be returned.  Specify
NULL if not required.

@var{cred_usage}: gss_cred_usage_t, modify, optional.  How the
credential may be used with the specified mechanism.  One of the
following: GSS_C_INITIATE, GSS_C_ACCEPT, GSS_C_BOTH.  Specify NULL if
not required.

Obtains per-mechanism information about a credential.

Valid return values and their meaning:

@code{GSS_S_COMPLETE}: Successful completion

@code{GSS_S_NO_CRED}: The referenced credentials could not be
accessed.

@code{GSS_S_DEFECTIVE_CREDENTIAL}: The referenced credentials were
invalid.

@code{GSS_S_CREDENTIALS_EXPIRED}: The referenced credentials have
expired.  If the lifetime parameter was not passed as NULL, it will be
set to 0.

@end deftypefun

@deftypefun OM_uint32 gss_release_cred (OM_uint32 * @var{minor_status}, gss_cred_id_t * @var{cred_handle})

@var{minor_status}:  Mechanism specific status code.

@var{cred_handle}:  Optional opaque handle identifying credential to be
released.  If GSS_C_NO_CREDENTIAL is supplied, the routine will
complete successfully, but will do nothing.

Informs GSS-API that the specified credential handle is no longer
required by the application, and frees associated resources.
Implementations are encouraged to set the cred_handle to
GSS_C_NO_CREDENTIAL on successful completion of this call.

Returns GSS_S_COMPLETE for successful completion, and GSS_S_NO_CRED
for credentials could not be accessed.

@end deftypefun

@node Context-Level Routines
@section Context-Level Routines

@verbatim
   Table 2-2  GSS-API Context-Level Routines

   Routine                 Section              Function
   -------                 -------              --------
   gss_init_sec_context       5.19 Initiate a security context with
                                   a peer application
   gss_accept_sec_context     5.1  Accept a security context
                                   initiated by a
                                   peer application
   gss_delete_sec_context     5.9  Discard a security context
   gss_process_context_token  5.25 Process a token on a security
                                   context from a peer application
   gss_context_time           5.7  Determine for how long a context
                                   will remain valid
   gss_inquire_context        5.20 Obtain information about a
                                   security context
   gss_wrap_size_limit        5.34 Determine token-size limit for
                                   gss_wrap on a context
   gss_export_sec_context     5.14 Transfer a security context to
                                   another process
   gss_import_sec_context     5.17 Import a transferred context
@end verbatim

@include texi/context.c.texi

@node Per-Message Routines
@section Per-Message Routines

@verbatim
   Table 2-3  GSS-API Per-message Routines

   Routine                 Section              Function
   -------                 -------              --------
   gss_get_mic                5.15 Calculate a cryptographic message
                                   integrity code (MIC) for a
                                   message; integrity service
   gss_verify_mic             5.32 Check a MIC against a message;
                                   verify integrity of a received
                                   message
   gss_wrap                   5.33 Attach a MIC to a message, and
                                   optionally encrypt the message
                                   content;
                                   confidentiality service
   gss_unwrap                 5.31 Verify a message with attached
                                   MIC, and decrypt message content
                                   if necessary.
@end verbatim

@deftypefun OM_uint32 gss_wrap (OM_uint32 * @var{minor_status}, const gss_ctx_id_t @var{context_handle}, int @var{conf_req_flag}, gss_qop_t @var{qop_req}, const gss_buffer_t @var{input_message_buffer}, int * @var{conf_state}, gss_buffer_t @var{output_message_buffer})

@var{minor_status}:  Mechanism specific status code.

@var{context_handle}:  Identifies the context on which the message will be sent

@var{conf_req_flag}:  Whether confidentiality is requested.

@var{qop_req}:  Specifies required quality of protection.  A
mechanism-specific default may be requested by setting qop_req to
GSS_C_QOP_DEFAULT.  If an unsupported protection strength is
requested, gss_wrap will return a major_status of GSS_S_BAD_QOP.

@var{input_message_buffer}:  Message to be protected.

@var{conf_state}:  Optional output variable indicating if confidentiality
services have been applied.

@var{output_message_buffer}:  Buffer to receive protected message.
Storage associated with this message must be freed by the
application after use with a call to @code{gss_release_buffer()}.

Attaches a cryptographic MIC and optionally encrypts the specified
input_message.  The output_message contains both the MIC and the
message.  The qop_req parameter allows a choice between several
cryptographic algorithms, if supported by the chosen mechanism.

Since some application-level protocols may wish to use tokens
emitted by @code{gss_wrap()} to provide "secure framing", implementations
must support the wrapping of zero-length messages.

 Returns

GSS_S_COMPLETE    Successful completion

GSS_S_CONTEXT_EXPIRED The context has already expired

GSS_S_NO_CONTEXT The context_handle parameter did not identify a
valid context

GSS_S_BAD_QOP     The specified QOP is not supported by the mechanism.

@end deftypefun

@deftypefun OM_uint32 gss_unwrap (OM_uint32 * @var{minor_status}, const gss_ctx_id_t @var{context_handle}, const gss_buffer_t @var{input_message_buffer}, gss_buffer_t @var{output_message_buffer}, int * @var{conf_state}, gss_qop_t * @var{qop_state})

@var{minor_status}:  Mechanism specific status code.

@var{context_handle}:  Identifies the context on which the message arrived

@var{input_message_buffer}:  input protected message

@var{output_message_buffer}:  Buffer to receive unwrapped message.
Storage associated with this buffer must be freed by the
application after use use with a call to @code{gss_release_buffer()}.

@var{conf_state}:  optional output variable indicating if confidentiality
protection was used.

@var{qop_state}:  optional output variable indicating quality of protection.

Converts a message previously protected by gss_wrap back to a
usable form, verifying the embedded MIC.  The conf_state parameter
indicates whether the message was encrypted; the qop_state
parameter indicates the strength of protection that was used to
provide the confidentiality and integrity services.

Since some application-level protocols may wish to use tokens
emitted by @code{gss_wrap()} to provide "secure framing", implementations
must support the wrapping and unwrapping of zero-length messages.

 Returns:

GSS_S_COMPLETE    Successful completion

GSS_S_DEFECTIVE_TOKEN The token failed consistency checks

GSS_S_BAD_SIG     The MIC was incorrect

GSS_S_DUPLICATE_TOKEN The token was valid, and contained a correct
MIC for the message, but it had already been processed

GSS_S_OLD_TOKEN The token was valid, and contained a correct MIC
for the message, but it is too old to check for duplication.

GSS_S_UNSEQ_TOKEN The token was valid, and contained a correct MIC
for the message, but has been verified out of sequence; a later
token has already been received.

GSS_S_GAP_TOKEN The token was valid, and contained a correct MIC
for the message, but has been verified out of sequence; an earlier
expected token has not yet been received.

GSS_S_CONTEXT_EXPIRED The context has already expired

GSS_S_NO_CONTEXT The context_handle parameter did not identify a
valid context

@end deftypefun

@node Name Manipulation
@section Name Manipulation

@verbatim
   Table 2-4  GSS-API Name manipulation Routines

   Routine                 Section              Function
   -------                 -------              --------
   gss_import_name            5.16 Convert a contiguous string name
                                   to internal-form
   gss_display_name           5.10 Convert internal-form name to
                                   text
   gss_compare_name           5.6  Compare two internal-form names

   gss_release_name           5.28 Discard an internal-form name
   gss_inquire_names_for_mech 5.24 List the name-types supported by
                                   the specified mechanism
   gss_inquire_mechs_for_name 5.23 List mechanisms that support the
                                   specified name-type
   gss_canonicalize_name      5.5  Convert an internal name to an MN
   gss_export_name            5.13 Convert an MN to export form
   gss_duplicate_name         5.12 Create a copy of an internal name
@end verbatim

@deftypefun OM_uint32 gss_import_name (OM_uint32 * @var{minor_status}, const gss_buffer_t @var{input_name_buffer}, const gss_OID @var{input_name_type}, gss_name_t * @var{output_name})

@var{minor_status}:  Mechanism specific status code

@var{input_name_buffer}:  buffer containing contiguous string name to convert

@var{input_name_type}:  Optional Object ID specifying type of printable
name.  Applications may specify either GSS_C_NO_OID to use a
mechanism-specific default printable syntax, or an OID recognized
by the GSS-API implementation to name a specific namespace.

@var{output_name}:  returned name in internal form.  Storage associated
with this name must be freed by the application after use with a call
to @code{gss_release_name()}.

Convert a contiguous string name to internal form.  In general, the
internal name returned (via the <output_name> parameter) will not
be an MN; the exception to this is if the <input_name_type>
indicates that the contiguous string provided via the
<input_name_buffer> parameter is of type GSS_C_NT_EXPORT_NAME, in
which case the returned internal name will be an MN for the
mechanism that exported the name.

 Returns GSS_S_COMPLETE for successful completion,
GSS_S_BAD_NAMETYPE when the input_name_type was unrecognized,
GSS_S_BAD_NAME when the input_name parameter could not be
interpreted as a name of the specified type, and GSS_S_BAD_MECH
when the input name-type was GSS_C_NT_EXPORT_NAME, but the
mechanism contained within the input-name is not supported.

@end deftypefun

@deftypefun OM_uint32 gss_display_name (OM_uint32 * @var{minor_status}, const gss_name_t @var{input_name}, gss_buffer_t @var{output_name_buffer}, gss_OID * @var{output_name_type})

@var{minor_status}:  Mechanism specific status code.

@var{input_name}:  Name to be displayed

@var{output_name_buffer}:  Buffer to receive textual name string.  The
application must free storage associated with this name after use
with a call to @code{gss_release_buffer()}.

@var{output_name_type}:  Optional type of the returned name.  The
returned gss_OID will be a pointer into static storage, and should
be treated as read-only by the caller (in particular, the
application should not attempt to free it). Specify NULL if not
required.

Allows an application to obtain a textual representation of an
opaque internal-form name for display purposes.  The syntax of a
printable name is defined by the GSS-API implementation.

If input_name denotes an anonymous principal, the implementation
should return the gss_OID value GSS_C_NT_ANONYMOUS as the
output_name_type, and a textual name that is syntactically distinct
from all valid supported printable names in output_name_buffer.

If input_name was created by a call to gss_import_name, specifying
GSS_C_NO_OID as the name-type, implementations that employ lazy
conversion between name types may return GSS_C_NO_OID via the
output_name_type parameter.

 Returns GSS_S_COMPLETE for successful completion,
GSS_S_BAD_NAME when input_name was ill-formed.

@end deftypefun

@deftypefun OM_uint32 gss_compare_name (OM_uint32 * @var{minor_status}, const gss_name_t @var{name1}, const gss_name_t @var{name2}, int * @var{name_equal})

@var{minor_status}:  Mechanism specific status code.

@var{name1}:  Internal-form name.

@var{name2}:  Internal-form name.

@var{name_equal}:  non-zero if names refer to same entity.

Allows an application to compare two internal-form names to
determine whether they refer to the same entity.

If either name presented to gss_compare_name denotes an anonymous
principal, the routines should indicate that the two names do not
refer to the same identity.

 Returns GSS_S_COMPLETE for successful completion,
GSS_S_BAD_NAMETYPE when the two names were of incomparable types,
and GSS_S_BAD_NAME if one or both of name1 or name2 was ill-formed.

@end deftypefun

@deftypefun OM_uint32 gss_release_name (OM_uint32 * @var{minor_status}, gss_name_t * @var{name})

@var{minor_status}:  Mechanism specific status code.

@var{name}:  The name to be deleted.

Free GSSAPI-allocated storage associated with an internal-form
name.  Implementations are encouraged to set the name to
GSS_C_NO_NAME on successful completion of this call.

 Returns GSS_S_COMPLETE for successful completion, and
GSS_S_BAD_NAME when the name parameter did not contain a valid
name.

@end deftypefun

@deftypefun OM_uint32 gss_canonicalize_name (OM_uint32 * @var{minor_status}, const gss_name_t @var{input_name}, const gss_OID @var{mech_type}, gss_name_t * @var{output_name})

@var{minor_status}:  Mechanism specific status code.

@var{input_name}:  The name for which a canonical form is desired.

@var{mech_type}:  The authentication mechanism for which the canonical
form of the name is desired.  The desired mechanism must be
specified explicitly; no default is provided.

@var{output_name}:  The resultant canonical name.  Storage associated
with this name must be freed by the application after use with a
call to @code{gss_release_name()}.

Generate a canonical mechanism name (MN) from an arbitrary internal
name.  The mechanism name is the name that would be returned to a
context acceptor on successful authentication of a context where
the initiator used the input_name in a successful call to
gss_acquire_cred, specifying an OID set containing <mech_type> as
its only member, followed by a call to gss_init_sec_context,
specifying <mech_type> as the authentication mechanism.

 Returns

GSS_S_COMPLETE    Successful completion.

GSS_S_BAD_MECH    The identified mechanism is not supported.

GSS_S_BAD_NAMETYPE The provided internal name contains no elements
that could be processed by the specified
mechanism.

GSS_S_BAD_NAME    The provided internal name was ill-formed.

@end deftypefun

@deftypefun OM_uint32 gss_inquire_names_for_mech (OM_uint32 *@var{minor_status}, const gss_OID @var{mechanism}, gss_OID_set *@var{name_types})

@var{minor_status}: Implementation specific status code.

@var{mechanism}: The mechanism to be interrogated.

@var{name_types}: Output set of name-types supported by the specified
mechanism.  The returned OID set must be freed by the application
after use with a call to gss_release_oid_set().

Outputs the set of nametypes supported by the specified mechanism.

Returns GSS_S_COMPLETE for successful completion.

@end deftypefun

@deftypefun OM_uint32 gss_inquire_mechs_for_name (OM_uint32 *@var{minor_status}, const gss_name_t @var{input_name}, gss_OID_set *@var{mech_types})

@var{minor_status}: Implementation specific status code.

@var{input_name}: The name to which the inquiry relates.

@var{mech_types}: Output set of mechanisms that may support the
specified name.  The returned OID set must be freed by the caller
after use with a call to gss_release_oid_set().

Outputs the set of mechanisms supported by the GSS-API implementation
that may be able to process the specified name.

Each mechanism returned will recognize at least one element within the
name.  It is permissible for this routine to be implemented within a
mechanism-independent GSS-API layer, using the type information
contained within the presented name, and based on registration
information provided by individual mechanism implementations.  This
means that the returned mech_types set may indicate that a particular
mechanism will understand the name when in fact it would refuse to
accept the name as input to gss_canonicalize_name(),
gss_init_sec_context(), gss_acquire_cred() or gss_add_cred() (due to
some property of the specific name, as opposed to the name type).
Thus this routine should be used only as a pre-filter for a call to a
subsequent mechanism-specific routine.

Returns GSS_S_COMPLETE for successful completion, GSS_S_BAD_NAME to
indicate that the input_name parameter was ill-formed, and
GSS_S_BAD_NAMETYPE to indicate that the input_name parameter contained
an invalid or unsupported type of name.

@end deftypefun

@deftypefun  OM_uint32 gss_canonicalize_name (OM_uint32 *@var{minor_status}, const gss_name_t @var{input_name}, const gss_OID @var{mech_type}, gss_name_t *@var{output_name})

@var{minor_status}: Mechanism specific status code.

@var{input_name}: The name for which a canonical form is desired.

@var{mech_type}: The authentication mechanism for which the canonical
form of the name is desired.  The desired mechanism must be specified
explicitly; no default is provided.

@var{output_name}: The resultant canonical name.  Storage associated
with this name must be freed by the application after use with a call
to gss_release_name().

Generate a canonical mechanism name (MN) from an arbitrary internal
name.  The mechanism name is the name that would be returned to a
context acceptor on successful authentication of a context where the
initiator used the input_name in a successful call to
gss_acquire_cred, specifying an OID set containing <mech_type> as its
only member, followed by a call to gss_init_sec_context, specifying
<mech_type> as the authentication mechanism.

Returns GSS_S_COMPLETE for successful completion, GSS_S_BAD_MECH to
indicate that the identified mechanism is not supported,
GSS_S_BAD_NAMETYPE to indicate that the provided internal name
contains no elements that could be processed by the specified
mechanism, and GSS_S_BAD_NAME to indicate that the provided internal
name was ill-formed.

@end deftypefun

@deftypefun OM_uint32 gss_export_name (OM_uint32 *@var{minor_status}, const gss_name_t @var{input_name}, gss_buffer_t @var{exported_name})

@var{minor_status}: Mechanism specific status code.

@var{input_name}: The mechanism name to be exported.

@var{exported_name}: Output variable with canonical contiguous string
form of @var{input_name}.  Storage associated with this string must
freed by the application after use with gss_release_buffer().

To produce a canonical contiguous string representation of a mechanism
name (MN), suitable for direct comparison (e.g. with memcmp) for use
in authorization functions (e.g. matching entries in an access-control
list).  The @var{input_name} parameter must specify a valid MN
(i.e. an internal name generated by gss_accept_sec_context or by
gss_canonicalize_name).

Returns GSS_S_COMPLETE for successful completion, GSS_S_NAME_NOT_MN to
indicate that the provided internal name was not a mechanism name,
GSS_S_BAD_NAME to indicate that the provided internal name was
ill-formed, and GSS_S_BAD_NAMETYPE to indicate that the internal name
was of a type not supported by the GSS-API implementation.

@end deftypefun

@deftypefun OM_uint32 gss_duplicate_name (OM_uint32 * @var{minor_status}, const gss_name_t @var{src_name}, gss_name_t * @var{dest_name})

@var{minor_status}:  Mechanism specific status code.

@var{src_name}:  Internal name to be duplicated.

@var{dest_name}:  The resultant copy of <src_name>.  Storage associated
with this name must be freed by the application after use with a
call to @code{gss_release_name()}.

Create an exact duplicate of the existing internal name src_name.
The new dest_name will be independent of src_name (i.e. src_name
and dest_name must both be released, and the release of one shall
not affect the validity of the other).

Returns GSS_S_COMPLETE for successful completion, and
GSS_S_BAD_NAME when the src_name parameter was ill-formed.

@end deftypefun

@node Miscellaneous Routines
@section Miscellaneous Routines

@verbatim
   Table 2-5  GSS-API Miscellaneous Routines

   Routine                Section              Function
   -------                -------              --------
   gss_add_oid_set_member    5.4  Add an object identifier to
                                  a set
   gss_display_status        5.11 Convert a GSS-API status code
                                  to text
   gss_indicate_mechs        5.18 Determine available underlying
                                  authentication mechanisms
   gss_release_buffer        5.26 Discard a buffer
   gss_release_oid_set       5.29 Discard a set of object
                                  identifiers
   gss_create_empty_oid_set  5.8  Create a set containing no
                                  object identifiers
   gss_test_oid_set_member   5.30 Determines whether an object
                                       identifier is a member of a set.
@end verbatim

@deftypefun OM_uint32 gss_release_buffer (OM_uint32 * @var{minor_status}, gss_buffer_t @var{buffer})

@var{minor_status}:  Mechanism specific status code.

@var{buffer}:  The storage associated with the buffer will be deleted.
The gss_buffer_desc object will not be freed, but its length field
will be zeroed.

Free storage associated with a buffer.  The storage must have been
allocated by a GSS-API routine.  In addition to freeing the
associated storage, the routine will zero the length field in the
descriptor to which the buffer parameter refers, and
implementations are encouraged to additionally set the pointer
field in the descriptor to NULL.  Any buffer object returned by a
GSS-API routine may be passed to gss_release_buffer (even if there
is no storage associated with the buffer).

Returns GSS_S_COMPLETE for successful completion.

@end deftypefun

@deftypefun OM_uint32 gss_create_empty_oid_set (OM_uint32 * @var{minor_status}, gss_OID_set * @var{oid_set})

@var{minor_status}:  Mechanism specific status code

@var{oid_set}:  The empty object identifier set. The routine will
allocate the gss_OID_set_desc object, which the application must free
after use with a call to @code{gss_release_oid_set()}.

Create an object-identifier set containing no object identifiers, to
which members may be subsequently added using the
@code{gss_add_oid_set_member()} routine.  These routines are intended
to be used to construct sets of mechanism object identifiers, for
input to gss_acquire_cred.

Returns GSS_S_COMPLETE for successful completion.

@end deftypefun

@deftypefun OM_uint32 gss_add_oid_set_member (OM_uint32 * @var{minor_status}, const gss_OID @var{member_oid}, gss_OID_set * @var{oid_set})

@var{minor_status}:  Mechanism specific status code

@var{member_oid}:  The object identifier to copied into the set.

@var{oid_set}:  The set in which the object identifier should be inserted.

Add an Object Identifier to an Object Identifier set.  This routine
is intended for use in conjunction with gss_create_empty_oid_set
when constructing a set of mechanism OIDs for input to
gss_acquire_cred.  The oid_set parameter must refer to an OID-set
that was created by GSS-API (e.g. a set returned by
@code{gss_create_empty_oid_set()}). GSS-API creates a copy of the
member_oid and inserts this copy into the set, expanding the
storage allocated to the OID-set's elements array if necessary.
The routine may add the new member OID anywhere within the elements
array, and implementations should verify that the new member_oid is
not already contained within the elements array; if the member_oid
is already present, the oid_set should remain unchanged.

Returns GSS_S_COMPLETE for successful completion.

@end deftypefun

@deftypefun OM_uint32 gss_test_oid_set_member (OM_uint32 * @var{minor_status}, const gss_OID @var{member}, const gss_OID_set @var{set}, int * @var{present})

@var{minor_status}:  Mechanism specific status code

@var{member}:  The object identifier whose presence is to be tested.

@var{set}:  The Object Identifier set.

@var{present}:  output indicating if the specified OID is a member of the
set, zero if not.

Interrogate an Object Identifier set to determine whether a specified
Object Identifier is a member.  This routine is intended to be used
with OID sets returned by @code{gss_indicate_mechs()},
@code{gss_acquire_cred()}, and @code{gss_inquire_cred()}, but will
also work with user-generated sets.

Returns GSS_S_COMPLETE for successful completion.

@end deftypefun

@deftypefun OM_uint32 gss_release_oid_set (OM_uint32 * @var{minor_status}, gss_OID_set * @var{set})

@var{minor_status}:  Mechanism specific status code

@var{set}:  The storage associated with the gss_OID_set will be deleted.

Free storage associated with a GSSAPI-generated gss_OID_set object.
The set parameter must refer to an OID-set that was returned from a
GSS-API routine.  @code{gss_release_oid_set()} will free the storage
associated with each individual member OID, the OID set's elements
array, and the gss_OID_set_desc.

Implementations are encouraged to set the gss_OID_set parameter to
GSS_C_NO_OID_SET on successful completion of this routine.

Returns GSS_S_COMPLETE for successful completion.

@end deftypefun

@deftypefun OM_uint32 gss_indicate_mechs (OM_uint32 *@var{minor_status}, gss_OID_set *@var{mech_set})

@var{minor_status}:  Mechanism specific status code.

@var{mech_set}:  Output OID set with implementation-supported mechanisms.

Allows an application to determine which underlying security
mechanisms are available.

The returned gss_OID_set value will be a dynamically-allocated OID
set, that should be released by the caller after use with a call to
gss_release_oid_set().

Returns GSS_S_COMPLETE for successful completion.

@end deftypefun

@deftypefun OM_uint32 gss_display_status (OM_uint32 *@var{minor_status}, OM_uint32 @var{status_value}, int @var{status_type}, const gss_OID @var{mech_type}, OM_uint32 *@var{message_context}, gss_buffer_t @var{status_string})

@var{minor_status}: Mechanism specific status code.

@var{status_value} Status value to be converted

@var{status_type}: Type of status code.  Valid values include
GSS_C_GSS_CODE to indicate that status_value is a GSS status code, and
GSS_C_MECH_CODE to indicate that status_value is a mechanism status
code.

@var{mech_type}: Optional OID of underlying mechanism (used to
interpret a minor status value) Supply GSS_C_NO_OID to obtain the
system default.

@var{message_context}: Input/output variable that should be
initialized to zero by the application prior to the first call.  On
return from gss_display_status(), a non-zero status_value parameter
indicates that additional messages may be extracted from the status
code via subsequent calls to gss_display_status(), passing the same
status_value, status_type, mech_type, and message_context parameters.

@var{status_string}: Output textual interpretation of the
status_value.  Storage associated with this parameter must be freed by
the application after use with a call to gss_release_buffer().

Allows an application to obtain a textual representation of a GSS-API
status code, for display to the user or for logging purposes.  Since
some status values may indicate multiple conditions, applications may
need to call gss_display_status multiple times, each call generating a
single text string.  The message_context parameter is used by
gss_display_status to store state information about which error
messages have already been extracted from a given status_value;
message_context must be initialized to 0 by the application prior to
the first call, and gss_display_status will return a non-zero value in
this parameter if there are further messages to extract.

The message_context parameter contains all state information required
by gss_display_status in order to extract further messages from the
status_value; even when a non-zero value is returned in this
parameter, the application is not required to call gss_display_status
again unless subsequent messages are desired.  The following code
extracts all messages from a given status code and prints them to
stderr:

@example
   OM_uint32 message_context;
   OM_uint32 status_code;
   OM_uint32 maj_status;
   OM_uint32 min_status;
   gss_buffer_desc status_string;

          ...

   message_context = 0;

   do @{


     maj_status = gss_display_status (
                     &min_status,
                     status_code,
                     GSS_C_GSS_CODE,
                     GSS_C_NO_OID,
                     &message_context,
                     &status_string)

     fprintf(stderr,
             "%.*s\n",
            (int)status_string.length,

            (char *)status_string.value);

     gss_release_buffer(&min_status, &status_string);

   @} while (message_context != 0);
@end example

Returns GSS_S_COMPLETE for successful completion, GSS_S_BAD_MECH to
indicate that translation in accordance with an unsupported mechanism
type was requested, and GSS_S_BAD_STATUS to indicate that the status
value was not recognized, or the status type was neither
GSS_C_GSS_CODE nor GSS_C_MECH_CODE.

@end deftypefun

@c **********************************************************
@c ************** Generic Security Services  ****************
@c **********************************************************
@node Extended GSS API
@chapter Extended GSS API

None of the following functions are standard GSS API functions.  As
such, they are not declared in @file{gss/api.h}, but rather in
@file{gss/ext.h} (which is included from @file{gss.h}).

@deftypefun {const char *} gss_check_version (const char * @var{req_version})

@var{req_version}:  version string to compare with, or NULL

Check that the the version of the library is at minimum the one given
as a string in @code{req_version} and return the actual version string
of the library; return NULL if the condition is not met.  If
@var{NULL} is passed to this function no check is done and only the
version string is returned.  It is a pretty good idea to run this
function as soon as possible, because it may also intializes some
subsystems.  In a multithreaded environment if should be called before
any more threads are created.

@end deftypefun

@deftypefun int gss_oid_equal (gss_OID @var{first_oid}, gss_OID @var{second_oid})

Compare two OIDs for equality.  Compares actual content, not just
pointer equality.  Returns a boolean true iff the OIDs are equal.

@end deftypefun

@deftypefun OM_uint32 gss_copy_oid (OM_uint32 * @var{minor_status}, const gss_OID @var{src_oid}, gss_OID @var{dest_oid});

Make an exact copy of the given OID, that shares no memory areas with
the original.  The contents of the copied OID must be deallocated by
the caller.  Returns GSS_S_COMPLETE on success.
@end deftypefun

@deftypefun OM_uint32 gss_duplicate_oid (OM_uint32 * @var{minor_status}, const gss_OID @var{src_oid}, gss_OID * @var{dest_oid})

Allocate an exact copy of the given OID, that shares no memory areas
with the original.  The newly created OID, and its contents, must be
deallocated by the caller.  Returns GSS_S_COMPLETE on success.

@end deftypefun

@deftypefun {int} gss_encapsulate_token (gss_buffer_t @var{input_message}, gss_OID @var{token_oid}, gss_buffer_t @var{output_message})

@var{input_message}: Message to be encapsulated.

@var{token_oid}: OID of mechanism.

@var{input_message}: Output buffer with encapsulated message.

Wrap a buffer in the mechanism-independent token format.  This is used
for the initial token of a GSS-API context establishment sequence.  It
incorporates an identifier of the mechanism type to be used on that
context, and enables tokens to be interpreted unambiguously at GSS-API
peers.  See further section 3.1 of RFC 2743.
@end deftypefun

@deftypefun {int} gss_decapsulate_token (gss_buffer_t @var{input_message}, gss_OID @var{token_oid}, gss_buffer_t @var{output_message})

@var{input_message}: Message to decapsulated.

@var{token_oid}: Output buffer with mechanism OID used in message.

@var{input_message}: Output buffer with encapsulated message.

Unwrap a buffer in the mechanism-independent token format.  This is
the reverse of @code{gss_encapsulate_token}.  The translation is
loss-less, all data is preserved as is.

@end deftypefun

@c **********************************************************
@c *******************  Acknowledgements  *******************
@c **********************************************************
@node Acknowledgements
@chapter Acknowledgements

This manual borrows text from RFC 2743 and RFC 2744 that describe GSS
API formally.

@c **********************************************************
@c *******************  Appendices  *************************
@c **********************************************************

@node Criticism of GSS
@appendix Criticism of GSS

The author has doubts whether GSS is the best solution for free
software projects looking for a implementation agnostic security
framework.  We express these doubts in this section, so that the
reader can judge for herself if any of the potential problems
discussed here are relevant for their project, or if the benefit
outweigh the problems.  We are aware that some of the opinions are
highly subjective, but we offer them in the hope they can serve as
anecdotal evidence.

GSS can be criticized on several levels.  We start with the actual
implementation.

GSS does not appear to be designed by experienced C programmers.
While generally this may be a good thing (C is not the best language),
but since they defined the API in C, it is unfortunate.  The primary
evidence of this is the major_status and minor_status error code
solution.  It is a complicated way to describe error conditions, but
what makes matters worse, the error condition is separated; half of
the error condition is in the function return value and the other half
is in the first argument to the function, which is always a pointer to
an integer.  (The pointer is not even allowed to be @code{NULL}, if
the application doesn't care about the minor error code.)  This makes
the API unreadable, and difficult to use.  A better solutions would be
to return a struct containing the entire error condition, which can be
accessed using macros, although we acknowledge that the C language
used at the time GSS was designed may not have allowed this (this may
in fact be the reason the awkward solution was chosen).  Instead, the
return value could have been passed back to callers using a pointer to
a struct, accessible using various macros, and the function could have
a void prototype.  The fact that minor_status is placed first in the
parameter list increases the pain it is to use the API.  Important
parameters should be placed first. A better place for minor_status (if
it must be present at all) would have been last in the prototypes.

Another evidence of the C inexperience are the memory management
issues; GSS provides functions to deallocate data stored within, e.g.,
@code{gss_buffer_t} but the caller is responsible of deallocating the
structure pointed at by the @code{gss_buffer_t} (i.e., the
@code{gss_buffer_desc}) itself.  Memory management issues are error
prone, and this division easily leads to memory leaks (or worse).
Instead, the API should be the sole owner of all @code{gss_ctx_id_t},
@code{gss_cred_id_t}, and @code{gss_buffer_t} structures: they should
be allocated by the library, and deallocated (using the utility
functions defined for this purpose) by the library.

TBA: thread issues

TBA: multiple mechanisms in a GSS library

TBA: high-level design criticism.

TBA: no credential forwarding.

TBA: internationalization

TBA: krb5: no way to access authorization-data

TBA: krb5: firewall/pre-IP: iakerb status?

TBA: krb5: single-DES only

TBA: the API may block, unusable in select() based servers.
Especially if the servers contacted is decided by the, yet
unauthenticated, remote client.

Finally we note that few free security applications uses GSS, perhaps
the only major exception to this are Kerberos 5 implementations.
While not substantial evidence, this do suggest that the GSS may not
be the simplest solution available to solve actual problems, since
otherwise more projects would have chosen to take advantage of the
work that went into GSS instead of using another framework (or
designing their own solution).

Our conclusion is that free software projects that are looking for a
security framework should evaluate carefully whether GSS actually is
the best solution before using it.  In particular it is recommended to
compare GSS with the Simple Authentication and Security Layer (SASL)
framework, which in several situations provide the same feature as GSS
does.  The most compelling argument for SASL over GSS is, as its
acronym suggest, Simple, whereas GSS is far from it.

However, that said, for free software projects that wants to support
Kerberos 5, we do acknowledge that no other framework provides a more
portable and interoperable interface into the Kerberos 5 system.  If
your project needs to use Kerberos 5 specifically, we do recommend you
to use GSS instead of the Kerberos 5 implementation specific APIs.

@c @node Copying This Manual
@c @appendix Copying This Manual
@c
@c @menu
@c * GNU Free Documentation License::  License for copying this manual.
@c @end menu

@c @include fdl.texi

@c @include gpl.texi

@node Concept Index
@unnumbered Concept Index

@printindex cp

@node API Index
@unnumbered API Index

@printindex fn

@summarycontents
@contents
@bye
